<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!--
Generated by HTML Help Compile Tools. You can modify this directly with the HTML editor of your choice,
or you can open it in Word, edit it, and save it as a .htm or .html file.
-->


<html>
	<head>
		<meta http-equiv="Content-Style-Type" content="text/css">
		<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
		<title>Receive Circular Buffer Format</title> <!--REPLACE-->
		<link rel="STYLESHEET" type="text/css" href="css/VSsystemexplorer.css">
		<script src="common.js" type="text/javascript"></script><script src="js/expandable_tree.js" type="text/javascript"></script>
		<link rel="STYLESHEET" type="text/css" href="css/expandable_tree.css">
		<script src="launchhelp.js" type="text/javascript"></script><script src="js/dynamicjumps.js" type="text/javascript"></script>
		<style type="text/css">
			th, td{
				border: 1px solid black;
				text-align: center;
			}
		</style>
	</head>
	<body>
		<noscript>
			<p class="Body">JavaScript is disabled. <a href="veristandmerge.chm::/JavaScript_Disabled.html">Details</a></p>
			<hr width="100%" noshade>
		</noscript>
		<h1>Receive Circular Buffer Format</h1> <!--REPLACE-->
		<h2>Introduction</h2>
		<p>
			Using the Circular Buffer options in the <i>Buffered Receive Packet</i> can be very powerful, allowing lossless receipt of high-speed packets on a network. However, using the Circular Buffer option requires a bit more care when reading the buffer. Additionally, several channels and features of a receive packet may no longer be functional, depending on the Circular Buffer option used.
			<!--Global scheme of why this screen is important and how it relates to the general process of setting up the custom device.-->
		</p>
		
		<h2>Circular Buffer</h2>
		<p>
			The standard Circular Buffer option is used to cyclically buffer inbound packets, adding them to buffer from start to end. When the end of the buffer is encountered, The packets get start overwriting entries at the beginning of the buffer. This option is suggested when packets have their own delimiters present.
			<h3>Format:</h3>
			<table>
				<tr>
					<th>Payload(0)</th>
					<th>Payload(1)</th>
					<th>Payload(n)</th>
					<th>--End of Buffer Encountered--</th>
					<th>Payload(n+1)</th>
				</tr>
				<tr>
					<td>Size(0) Bytes - Untyped</td>
					<td>Size(1) Bytes - Untyped</td>
					<td>Size(n) Bytes - Untyped</td>
					<td>--Reset to Beginning of Buffer--</td>
					<td>Size(n+1) Bytes - Untyped</td>
				</tr>
			</table>

			<h3>Rules:</h3>
			<ul>
				<li>Packets always are added to the beginning of the buffer first.</li>
				<li>Packets are always placed adjacent to each other with no special markers or delimiting.</li>
				<li>When the end of the buffer is encountered, packets will begin to overwrite older packets at the beginning of the buffer.</li>
				<li>If a packet requires more space than is available in the remainder of the buffer, the packet will instead be placed at the beginning of the circular buffer, overwriting old packet data.</li>
				<li>The packet count will increment for all received packets. This is the suggested means for tracking the current location in the buffer.</li>
				<li>The <i>Bytes Received</i> channel will no longer work as intended.</li>
				<li>The <i>Port</i> channel will only display the <STRONG>LATEST</STRONG> sending port.</li>
			</ul>
		</p>
		<h2>Circular Buffer + Size</h2>
		<p>
			The size Circular Buffer option is used to retain the size of each payload received. Each received payload is pre-empted with a size value. This option works largely in the same way as the Circular Buffer option. This option is suggested when inbound packets lack meaningful formatting, as the additional in-memory delimiters can greatly assist with buffer traversal.
			<h3>Format:</h3>
			<table>
				<tr>
					<th>Size(0)</th>
					<th>Payload(0)</th>
					<th>Size(1)</th>
					<th>Payload(1)</th>
					<th>Size(n)</th>
					<th>Payload(n)</th>
					<th>ROLLOVER FIELD</th>
					<th>--End of Buffer Encountered--</th>
					<th>Size(n+1)</th>
					<th>Payload(n+1)</th>
					<th>NULL FIELD</th>
				</tr>
				<tr>
					<td>4 Bytes - I32</td>
					<td>Size(0) Bytes - Untyped</td>
					<td>4 Bytes - I32</td>
					<td>Size(1) Bytes - Untyped</td>
					<td>4 Bytes - I32</td>
					<td>Size(n) Bytes - Untyped</td>
					<td>4 Bytes - I32 (-1)</td>
					<td>--Reset to Beginning of Buffer--</td>
					<td>4 Bytes - I32</td>
					<td>Size(n+1) Bytes - Untyped</td>
					<td>4 Bytes - Null</td>
				</tr>
			</table>
			<h3>Rules:</h3>
			<ul>
				<li>Packets always are added to the beginning of the buffer first.</li>
				<li>Packets are always placed adjacent to each other with a size delimiter taking up four bytes before the packet.</li>
				<li>When a packet is done being written to the buffer, the <i>NULL FIELD</i> value is written to the 4 bytes following the packet. This field is overwritten by the size delimiter upon receipt of the next packet.</li>
				<li>When the end of the buffer is encountered, packets will begin to overwrite older packets at the beginning of the buffer.</li>
				<li>If a packet requires more space than is available in the remainder of the buffer, the packet will instead be placed at the beginning of the circular buffer, overwriting old packet data. This is a roll-over event.</li>
				<li>If a roll-over occurs, the final <i>NULL FIELD</i> n the buffer will be filled with a -1 value. This is functionally 4 consecutive bytes of 0xFF.</li>
				<li>The packet count will increment for all received packets. This is the suggested means for tracking the current location in the buffer.</li>
				<li>The <i>Bytes Received</i> channel will no longer work as intended.</li>
				<li>The <i>Port</i> channel will only display the <STRONG>LATEST</STRONG> sending port.</li>
			</ul>
		</p>
	</body>
	<footer>
		<a href="CD - Buffered Data Rx Packet.htm">Back</a> <!--REPLACE - Should refer to the previous page-->
		<hr>
	</footer>
</html> 
